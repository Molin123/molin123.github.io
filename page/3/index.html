<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-utilInherits" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/11/utilInherits/" class="article-date">
  <time datetime="2016-05-11T10:03:00.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/utilInherits/">util.inherits实现对象间原型继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>util是 node 的一个核心模块，引入方法：<br><code>var util = require(&#39;util&#39;);</code></p>
<h2 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h2><p>util.inherits(A,B)是实现对象间原型继承的函数。这和JavaScript中类似，具体实现方法如下：</p>
<pre><code>var util = require(&apos;util&apos;); //引入util木块
//创建一个对象Base
function Base() {
    this.name = &apos;molin&apos;;
    this.sayHello = function() {
        console.log(&apos;Hello &apos; + this.name);
    }
}
//向Base原型中增加方法
Base.prototype.showName = function() {
    console.log(&apos;Name: &apos; + this.name);
}
//创建一个新的Sub对象
function Sub() {
    this.name = &apos;sub&apos;;
}
//实现继承
util.inherits(Sub, Base);

var objBase = new Base();
console.log(objBase); //Base { name: &apos;molin&apos;, sayHello: [Function] }
objBase.showName();  //Name: molin
objBase.sayHello(); //Hello molin

var objSub = new Sub();
console.log(objSub); //Sub {name: &apos;sub&apos;}
objSub.showName(); //sub
objSub.sayHello();  //会报错
</code></pre><p>上面的代码如果有最后一样就会报错。这是因为 util.inherits 只能继承 Base 在原型中定义的哈数，而在构造函数中定义的 sayHello 是不会被继承的。<br>另外还需要注意一点， console.log 只能输出在构造函数中定义的属性和方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/11/utilInherits/" data-id="cirx73hvm000ue2ufgtotb822" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jseventutil" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/04/jseventutil/" class="article-date">
  <time datetime="2016-05-04T02:12:08.000Z" itemprop="datePublished">2016-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/04/jseventutil/">手写事件模型及事件代理/委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h3><ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">'button'</span> onclick=<span class="string">"alert('Clicked')"</span> /&gt;</div></pre></td></tr></table></figure>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序中的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">删除：```btn.onclick=null;//删除事件处理程序</div></pre></td></tr></table></figure></p>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">addEventListener();</div><div class="line">removeEventListener();</div></pre></td></tr></table></figure>
<p>三个参数：要处理的事件名；作为事件处理程序的函数，一个布尔值（true：捕获阶段调用；false：冒泡阶段调用）。</p>
<p>可以添加多个事件处理程序，按照添加的顺序触发。</p>
<p>移除时传入的参数与添加处理程序时使用的参数必须相同，这意味着通过其添加的匿名函数无法移除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(<span class="string">'click'</span>,hander,<span class="literal">false</span>);</div><div class="line">btn.removeEventListener(<span class="string">'click'</span>,hander,<span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。</p>
<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">attachEvent();</div><div class="line">detachEvent();</div></pre></td></tr></table></figure>
<p>两个参数：事件处理程序名称；事件处理程序函数。</p>
<p>注意：第一个参数是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```js</div><div class="line">btn.attachEvent(&apos;onclick&apos;,hander);</div><div class="line">btn,detachEvent(&apos;onclick&apos;,hander);</div></pre></td></tr></table></figure></p>
<p>也可以添加多个事件处理程序，但是执行顺序相反，后添加的先被执行。</p>
<h3 id="事件对象（非IE浏览器）"><a href="#事件对象（非IE浏览器）" class="headerlink" title="事件对象（非IE浏览器）"></a>事件对象（非IE浏览器）</h3><p>在触发DOM上的某个事件时，会产生一个事件对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">&lt;input type=&apos;button&apos; onclick=&apos;alert(event.type)&apos; /&gt;</div></pre></td></tr></table></figure></p>
<p>兼容DOM(DOM0级或DOM2级)的浏览器会将一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">btn.onclick=function(event)&#123;alert(event.type);&#125;    //&apos;click&apos;</div><div class="line">btn.addEventListener(&apos;click&apos;,function(event)&#123;alert(event.type);&#125;,false);   //&apos;click&apos;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>其事件处理程序当前正在处理事件的那个元素。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```target```：事件的目标。</div><div class="line"></div><div class="line">在事件处理程序内部，对象```this```始终等于```currentTarget```的值，而```target```则只包含事件的实际目标。如果直接将事件处理程序制定给了目标元素，则```this```、```currentTarget```和```target```包含相同的值。</div><div class="line">```js</div><div class="line">btn.onclick = function(event)&#123;</div><div class="line">    alert(event.currentTarget === this);        //true</div><div class="line">    alert(event.target === this);               //true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果事件处理程序存在于按钮的父节点中，则不相同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.boy.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(event.currentTarget === <span class="built_in">document</span>.body);             <span class="comment">//true</span></div><div class="line">    alert(<span class="keyword">this</span> === body);                                     <span class="comment">//true</span></div><div class="line">    alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)); <span class="comment">//true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>阻止默认行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;event.preventDefault();&#125;;</div></pre></td></tr></table></figure></p>
<p>事件的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">btn.onclick = function(event)&#123;</div><div class="line">    alert(event.eventPhase);      //2 -&gt; 目标</div><div class="line">&#125;;</div><div class="line">document.body.addEventListener(&apos;click&apos;,function(event)&#123;</div><div class="line">    alert(event.eventPhase);      //1 -&gt; 捕获</div><div class="line">&#125;,true);</div><div class="line">document.body.onclick = function(event)&#123;</div><div class="line">    alert(event.eventPhase);      //3 -&gt; 冒泡</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>立刻停止事件的传播（捕获、冒泡）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">btn.onclick = function(event)&#123;</div><div class="line">    alert(1);</div><div class="line">    event.stopPropagation();</div><div class="line">&#125;</div><div class="line">document.body.onclick = function(event)&#123;</div><div class="line">    alert(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于阻止了事件的继续传播，所以上面的代码不会弹出2.</p>
<p>我们可以通过使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">var handler = function(event)&#123;</div><div class="line">    switch(event.type)&#123;</div><div class="line">        case &apos;click&apos;:</div><div class="line">            alert(&apos;Clicked&apos;);</div><div class="line">            break;</div><div class="line">        case &apos;mouseover&apos;:</div><div class="line">            alert(&apos;MouseOver&apos;);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">btn.onclick = handler;</div><div class="line">btn.onmouseover = handler;</div></pre></td></tr></table></figure></p>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>使用DOM0：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</div><div class="line">    alert(event.type);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用DOM2：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.attachEvent(<span class="string">'onclick'</span>,funciton(event)&#123;</div><div class="line">    alert(event.type);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>事件的目标：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为```this```会始终等于事件目标。故而，最好还是使用```event.srcElement```比较保险。例如：</div><div class="line">```js</div><div class="line">btn.onclick = funciton()&#123;</div><div class="line">    alert(window.event.srcElement === this);        //true</div><div class="line">&#125;</div><div class="line">btn.attachEvent(&apos;onclick&apos;,function(event)&#123;</div><div class="line">    alert(event.srcElement === this);              //false</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>取消默认行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取消冒泡：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.event.cancleBubble = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<h3 id="兼容的事件处理函数"><a href="#兼容的事件处理函数" class="headerlink" title="兼容的事件处理函数"></a>兼容的事件处理函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);   <span class="comment">//false冒泡时触发</span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(element.removeEventListener)&#123;</div><div class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</div><div class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event?event:<span class="built_in">window</span>.event;</div><div class="line">    &#125;,</div><div class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;      <span class="comment">//事件的实际目标</span></div><div class="line">    &#125;,</div><div class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;       <span class="comment">//取消时间的默认行为</span></div><div class="line">        <span class="keyword">if</span>(event.preventDefault)&#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;      <span class="comment">//立即停止事件的传播（取消捕获、冒泡）</span></div><div class="line">        <span class="keyword">if</span>(event.stopPropagation)&#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/04/jseventutil/" data-id="cirx73hv6000me2ufs9or9qp0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jsnew" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/04/jsnew/" class="article-date">
  <time datetime="2016-05-04T02:06:53.000Z" itemprop="datePublished">2016-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/04/jsnew/">new操作符具体干了什么呢?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>创建一个空对象，并且this对象引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到this引用的对象中</li>
<li>新创建的对象由this所引用，并且最后隐式地返回this<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/04/jsnew/" data-id="cirx73hvb000oe2ufsrdnz4k7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jsbind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/jsbind/" class="article-date">
  <time datetime="2016-05-03T13:31:07.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/jsbind/">js的bind方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在javascript中，函数总是在一个特殊的上下文执行（称为执行上下文），如果你将一个对象的函数赋值给另外一个变量的话，这个函数的执行上下文就变为这个变量的上下文了。下面的一个例子能很好的说明这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name: <span class="string">'a'</span>,</div><div class="line">    alertName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = a.alertName;</div><div class="line">b();                             <span class="comment">//空</span></div><div class="line"><span class="keyword">var</span> c = a.alertName.bind(a);</div><div class="line">c();                             <span class="comment">//'a'</span></div></pre></td></tr></table></figure></p>
<p>bind方法返回的是一个函数，而call方法是改变上下文this并执行函数。bind兼容处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _self = <span class="keyword">this</span></div><div class="line">            ,args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            _self.apply(obj, <span class="built_in">Array</span>.prototype.slice.call(args, <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/jsbind/" data-id="cirx73hv1000ke2ufiwwqua7v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/closure/" class="article-date">
  <time datetime="2016-05-03T06:39:47.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/closure/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p>闭包有三个特性</p>
<ol>
<li>函数嵌套函数</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<h3 id="闭包的定义及其优缺点"><a href="#闭包的定义及其优缺点" class="headerlink" title="闭包的定义及其优缺点"></a>闭包的定义及其优缺点</h3><p><code>闭包</code>是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量</p>
<p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p>闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。</p>
<p>一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！</p>
<h3 id="嵌套函数的闭包"><a href="#嵌套函数的闭包" class="headerlink" title="嵌套函数的闭包"></a>嵌套函数的闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function aaa() &#123;</div><div class="line">    var a = 1;</div><div class="line">    return function()&#123;</div><div class="line">        alert(a++)</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var fun = aaa();</div><div class="line">fun();// 1 执行后 a++，，然后a还在~</div><div class="line">fun();// 2</div><div class="line">fun = null;//a被回收！！</div></pre></td></tr></table></figure>
<p>闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/closure/" data-id="cirx73htw0004e2uf3ossma5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-h5scroll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/h5scroll/" class="article-date">
  <time datetime="2016-05-03T05:22:39.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/h5scroll/">h5中滚动的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这周的新项目开发中，遇到了一个头疼的问题。手机端给容器设置 overflow-y:scroll 后，会发现滚动慢，明显存在滚动障碍。这个问题是在项目中的一个弹层中出现的，本来以为是由 position:fixed 造成的，再经过多次测试后，发现并不是fixed的锅。只要是非body的滚动，都会存在这个问题。<br>终于在网上找到了一个不标准的属性：-webkit-overflow-scrolling: touch; 在容器上加上了这个属性后，问题得以解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-webkit-overflow-scrolling: touch；//允许独立的滚动区域和触摸回弹</div></pre></td></tr></table></figure></p>
<p>详细的介绍可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/h5scroll/" data-id="cirx73hum000de2ufcykszl14" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Front-end-Interview-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/Front-end-Interview-questions/" class="article-date">
  <time datetime="2016-05-03T05:22:39.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/Front-end-Interview-questions/">前端面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##一些开放性题目</p>
<pre><code>1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。

2.项目介绍

3.如何看待前端开发？

4.平时是如何学习前端开发的？

5.未来三年的规划是怎样的？
</code></pre><p><br></p>
<p>##position的值， relative和absolute分别是相对于谁进行定位的？</p>
<ul>
<li><p><code>absolute</code> :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</p>
</li>
<li><p><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
</li>
<li><p><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
</li>
<li><p><code>static</code>  默认值。没有定位，元素出现在正常的流中</p>
</li>
</ul>
<p><br></p>
<p>##如何解决跨域问题</p>
<p>####JSONP：</p>
<p>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入。</p>
<p>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把JSON填充到一个盒子里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">        oScript.type = <span class="string">'text/javascript'</span>;</div><div class="line">        oScript.src = sUrl;</div><div class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createJs(<span class="string">'jsonp.js'</span>);</div><div class="line"></div><div class="line">    box(&#123;</div><div class="line">       <span class="string">'name'</span>: <span class="string">'test'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">        alert(json.name);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>####CORS</p>
<p>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问。</p>
<p>####通过修改document.domain来跨子域</p>
<p>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域</p>
<p>主域相同的使用<code>document.domain</code></p>
<p>###使用window.name来进行跨域</p>
<p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</p>
<p>####使用HTML5中新引进的<code>window.postMessage</code>方法来跨域传送数据</p>
<p>还有flash、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>
<h2 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a><code>XML</code>和<code>JSON</code>的区别？</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(1).数据体积方面。</div><div class="line"></div><div class="line">JSON相对于XML来讲，数据的体积小，传递的速度更快些。</div><div class="line"></div><div class="line">(2).数据交互方面。</div><div class="line"></div><div class="line">JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</div><div class="line"></div><div class="line">(3).数据描述方面。</div><div class="line"></div><div class="line">JSON对数据的描述性比XML较差。</div><div class="line"></div><div class="line">(4).传输速度方面。</div><div class="line"></div><div class="line">JSON的速度要远远快于XML。</div></pre></td></tr></table></figure>
<p>##谈谈你会webpack的看法</p>
<p><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的<code>HTML、Javascript、CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p>
<p><code>webpack</code>是加强版的<code>Browserify</code>。</p>
<p><code>webpack</code>的两大特色：</p>
<pre><code>1.code splitting（可以自动完成）

2.loader 可以处理各种类型的静态文件，并且支持串联操作
</code></pre><p>###webpack的优势：</p>
<ul>
<li><p><code>require.js</code>的所有功能它都有。</p>
</li>
<li><p>编绎过程更快，因为<code>require.js</code>会去处理不需要的文件</p>
</li>
</ul>
<p><code>webpack</code> 是以<code>commonJS</code>的形式来书写脚本滴，但对 <code>AMD/CMD</code> 的支持也很全面，方便旧项目进行代码迁移。</p>
<p><code>webpack</code>具有<code>requireJs</code>和<code>browserify</code>的功能，但仍有很多自己的新特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. 对 CommonJS 、 AMD 、ES6的语法做了兼容</div><div class="line"></div><div class="line">2. 对js、css、图片等资源文件都支持打包</div><div class="line"></div><div class="line">3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</div><div class="line"></div><div class="line">4. 有独立的配置文件webpack.config.js</div><div class="line"></div><div class="line">5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</div><div class="line"></div><div class="line">6. 支持 SourceUrls 和 SourceMaps，易于调试</div><div class="line"></div><div class="line">7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</div><div class="line"></div><div class="line">8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</div></pre></td></tr></table></figure>
<h2 id="说说TCP传输的三次握手四次挥手策略"><a href="#说说TCP传输的三次握手四次挥手策略" class="headerlink" title="说说TCP传输的三次握手四次挥手策略"></a>说说TCP传输的三次握手四次挥手策略</h2><p> 为了准确无误地把数据送达目标处，<code>TCP</code>协议采用了三次握手策略。用TCP协议把数据包送出去后，<code>TCP</code>不会对传送    后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：<code>SYN</code>和<code>ACK</code>。</p>
<p>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p>
<p><br></p>
<blockquote>
<p>断开一个TCP连接则需要“四次握手”：</p>
</blockquote>
<ul>
<li><p>第一次挥手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
</li>
<li><p>第二次挥手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</p>
</li>
<li><p>第三次挥手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
</li>
<li><p>第四次挥手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p>
<p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的。</p>
<h2 id="onmousemove和onmouseover的区别："><a href="#onmousemove和onmouseover的区别：" class="headerlink" title="onmousemove和onmouseover的区别："></a>onmousemove和onmouseover的区别：</h2><pre><code>时间上：onmousemove事件触发后，再触发onmouseover事件。

按钮上：不区分鼠标按钮。

动作上：onmouseover只在刚进入区域时触发，onmousemove除了刚进入区域触发外，在区域内移动鼠标，也会触发
</code></pre><p>##创建ajax过程</p>
<pre><code>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.
</code></pre><p>##渐进增强和优雅降级</p>
<p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>##常见web安全及防护原理</p>
<p>####sql注入原理</p>
<p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>总的来说有以下几点：</p>
<pre><code>1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等。

2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。

3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
</code></pre><p>####XSS原理及防范</p>
<p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 <code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个</p>
<p>看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，</p>
<p>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>
<p>####XSS防范方法</p>
<p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p>
<p>首先，避免直接在<code>cookie</code> 中泄露用户隐私，例如email、密码等等。</p>
<p>其次，通过使<code>cookie</code> 和系统<code>ip</code> 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的<code>cookie</code> 没有实际价值，不可能拿来重放。</p>
<p>尽量采用<code>POST</code> 而非<code>GET</code> 提交表单</p>
<p>####XSS与CSRF有什么区别吗？</p>
<p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p>
<p>要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">登录受信任网站A，并在本地生成Cookie。</div><div class="line"></div><div class="line">在不登出A的情况下，访问危险网站B。</div></pre></td></tr></table></figure>
<p>###CSRF的防御</p>
<ul>
<li><p>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p>
</li>
<li><p>通过验证码的方法</p>
</li>
</ul>
<p>##Web Worker 和webSocket</p>
<p>###worker主线程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>通过 worker = <span class="keyword">new</span> Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</div><div class="line"></div><div class="line"><span class="number">2.</span>通过worker.postMessage( data ) 方法来向worker发送数据。</div><div class="line"></div><div class="line"><span class="number">3.</span>绑定worker.onmessage方法来接收worker发送过来的数据。</div><div class="line"></div><div class="line"><span class="number">4.</span>可以使用 worker.terminate() 来终止一个worker的执行。</div></pre></td></tr></table></figure>
<p><code>WebSocket</code>是<code>Web</code>应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个<code>HTML5</code>协议，<code>WebSocket</code>的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p>
<p>###HTTP和HTTPS</p>
<p><code>HTTP</code>协议通常承载于TCP协议之上，有时也承载于<code>TLS</code>或<code>SSL</code>协议层之上，这个时候，就成了我们常说的HTTPS。</p>
<p>默认HTTP的端口号为80，<code>HTTPS</code>的端口号为443。</p>
<p>###为什么<code>HTTPS</code>安全</p>
<p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<code>HTTPS</code>，密钥在你和终点站才有。<code>https</code>之所以比<code>http</code>安全，是因为他利用<code>ssl/tls</code>协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>
<p>###对前端模块化的认识</p>
<blockquote>
<p>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。</p>
<p>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<blockquote>
<p>CMD模块方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 模块代码</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>##Javascript垃圾回收方法</p>
<p>###标记清除（mark and sweep）</p>
<p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
<p>###引用计数(reference counting)</p>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及<code>BOM</code>及DOM就会出现循环引用问题。</p>
<p>###你觉得前端工程的价值体现在哪</p>
<pre><code>为简化用户使用提供技术支持（交互部分）

为多个浏览器兼容性提供支持

为提高用户浏览速度（浏览器性能）提供支持

为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持

为展示数据提供支持（数据接口）
</code></pre><p>###谈谈性能优化问题</p>
<p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</p>
<p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p>
<p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p>
<p>请求带宽：压缩文件，开启GZIP，</p>
<blockquote>
<p>代码层面的优化</p>
</blockquote>
<ul>
<li><p>用<code>hash-table</code>来优化查找</p>
</li>
<li><p>少用全局变量</p>
</li>
<li><p>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</p>
</li>
<li><p>用<code>setTimeout</code>来避免页面失去响应</p>
</li>
<li><p>缓存DOM节点查找的结果</p>
</li>
<li><p>避免使用CSS Expression</p>
</li>
<li><p>避免全局查询</p>
</li>
<li><p>避免使用width(width会创建自己的作用域，会增加作用域链长度)</p>
</li>
<li><p>多个变量声明合并</p>
</li>
</ul>
<p>###移动端性能优化</p>
<p>1.尽量使用css3动画，开启硬件加速。适当使用<code>touch</code>事件代替<code>click</code>事件。避免使用<code>css3</code>渐变阴影效果。</p>
<p>###什么是Etag？</p>
<p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。<br></p>
<p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到  <code>200 OK</code>(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p>
<p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和<code>Etag</code></p>
<p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据<code>Etag</code>，判断文件内容自上一次请求之后，有没有发生变化</p>
<p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发<code>index.html</code>的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code>，此时浏览器就会从本地缓存中获取<code>index.html</code>的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。<br></p>
<p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</p>
<p><br></p>
<p>① 只有get请求会被缓存，post请求不会</p>
<p>###Expires和Cache-Control</p>
<p><code>Expires</code>要求客户端和服务端的时钟严格同步。<code>HTTP1.1</code>引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Cache-Control: no-cache, private, max-age=<span class="number">0</span></div><div class="line"></div><div class="line">ETag: abcde</div><div class="line"></div><div class="line">Expires: Thu, <span class="number">15</span> Apr <span class="number">2014</span> <span class="number">20</span>:<span class="number">00</span>:<span class="number">00</span> GMT</div><div class="line"></div><div class="line">Pragma: private</div><div class="line"></div><div class="line">Last-Modified: $now <span class="comment">// RFC1123 format</span></div></pre></td></tr></table></figure>
<p>###ETag应用:</p>
<p><code>Etag</code>由服务器端生成，客户端通过<code>If-Match</code>或者说<code>If-None-Match</code>这个条件判断请求来验证资源是否修改。常见的是使用<code>If-None-Match</code>。请求一个文件的流程可能如下：</p>
<p>====第一次请求===</p>
<pre><code>1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200
</code></pre><p>====第二次请求===</p>
<pre><code>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
</code></pre><p>答案是同时使用，也就是说在完全匹配<code>If-Modified-Since</code>和<code>If-None-Match</code>即检查完修改时间和<code>Etag</code>之后，</p>
<p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p>
<p>为什么使用Etag请求头?</p>
<p>Etag 主要为了解决 <code>Last-Modified</code> 无法解决的一些问题。</p>
<p>###栈和队列的区别?</p>
<pre><code>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除
</code></pre><p>###栈和堆的区别？</p>
<pre><code>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。

堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。
</code></pre><p>###快速 排序的思想并实现一个快排？</p>
<p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<p>　　（1）在数据集之中，找一个基准点</p>
<p>　　（2）建立两个数组，分别存储左边和右边的数组</p>
<p>　　（3）利用递归进行下次比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></div><div class="line">        <span class="keyword">var</span> left = [];</div><div class="line">        <span class="keyword">var</span> right = [];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i]&lt;numValue)&#123;</div><div class="line">                left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">               right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>###你觉得jQuery或zepto源码有哪些写的好的地方</p>
<p><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当<code>jquery</code>中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问<code>window</code>对象。同样，传入<code>undefined</code>参数，可以缩短查找undefined时的作用域链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">//用一个函数域包起来，就是所谓的沙箱</span></div><div class="line"></div><div class="line">     <span class="comment">//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span></div><div class="line"></div><div class="line">     <span class="comment">//把当前沙箱需要的外部变量通过函数参数引入进来</span></div><div class="line"></div><div class="line">     <span class="comment">//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line"></div><div class="line">&#125;)( <span class="built_in">window</span> );</div></pre></td></tr></table></figure>
<p>jquery将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法。</p>
<p>有一些数组或对象的方法经常能使用到，应将它们保存为局部变量以提高访问速度。</p>
<p>将全局对象window作为参数传入，则可以使之在匿名函数内部作为局部变量访问，提供访问速度。</p>
<p><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>
<p>###ES6的了解</p>
<p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值<code>Inputs=&gt;outputs</code>。）、<code>for-of</code>（用来遍历数据—例如数组中的值。）<code>arguments</code>对象可被不定参数和默认参数完美代替。<code>ES6</code>将<code>promise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。增加了<code>let</code>和<code>const</code>命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，属于全局对象的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。。还有就是引入<code>module</code>模块的概念</p>
<p>###js继承方式及其优缺点</p>
<blockquote>
<p>原型链继承的缺点</p>
</blockquote>
<pre><code>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
</code></pre><blockquote>
<p>借用构造函数（类式继承）</p>
</blockquote>
<pre><code>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承
</code></pre><blockquote>
<p>组合式继承</p>
</blockquote>
<pre><code>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
</code></pre><p>具体请看：<a href="http://segmentfault.com/a/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<p>###关于Http 2.0 你知道多少？</p>
<p><code>HTTP/2</code>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
<p><code>HTTP/2</code>提供更多的加密支持</p>
<p><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。</p>
<p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p>
<p><br></p>
<blockquote>
<p>defer并行加载js文件，会按照页面上script标签的顺序执行<br>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p>
</blockquote>
<p>###谈谈浮动和清除浮动</p>
<p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p>
<p>###如何评价AngularJS和BackboneJS</p>
<p><code>backbone</code>具有依赖性，依赖<code>underscore.js</code>。<code>Backbone + Underscore + jQuery(or Zepto)</code> 就比一个<code>AngularJS</code> 多出了2 次HTTP请求.</p>
<p><br></p>
<p><code>Backbone</code>的<code>Model</code>没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。<code>AngularJS</code>与此相反，Model直接与UI视图绑定，<code>Model</code>与UI视图的关系，通过<code>directive</code>封装，<code>AngularJS</code>内置的通用<code>directive</code>，就能实现大部分操作了，也就是说，基本不必关心<code>Model</code>与UI视图的关系，直接操作Model就行了，UI视图自动更新。</p>
<p><br></p>
<p><code>AngularJS</code>的<code>directive</code>，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。</p>
<p>###用过哪些设计模式？</p>
<blockquote>
<p>工厂模式：</p>
</blockquote>
<pre><code>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。

    工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。


function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.profession = profession;
    obj.move = function () {
        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;
    };
    return obj;
}
var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例
</code></pre><p><br></p>
<p>###构造函数模式</p>
<p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p>
<pre><code>1.构造函数方法没有显示的创建对象 (new Object());

2.直接将属性和方法赋值给 this 对象;

3.没有 renturn 语句。
</code></pre><p>##说说你对闭包的理解</p>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p>闭包有三个特性：</p>
<blockquote>
<p>1.函数嵌套函数</p>
<p>2.函数内部可以引用外部的参数和变量</p>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
<p> 具体请看：<a href="http://segmentfault.com/a/1190000000652891" target="_blank" rel="external">详解js闭包</a></p>
<p>###请你谈谈Cookie的弊端</p>
<p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p>
<p>第一：每个特定的域名下最多生成20个<code>cookie</code></p>
<pre><code>1.IE6或更低版本最多20个cookie

2.IE7和之后的版本最后可以有50个cookie。

3.Firefox最多50个cookie

4.chrome和Safari没有做硬性限制
</code></pre><p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>userdata</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<p>###优点：极高的扩展性和可用性</p>
<pre><code>1.通过良好的编程，控制保存在cookie中的session对象的大小。

2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。

3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。

4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
</code></pre><p>###缺点：</p>
<pre><code>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.


2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><p>###浏览器本地存储</p>
<p>在较高版本的浏览器中，<code>js</code>提供了<code>sessionStorage</code>和<code>globalStorage</code>。在<code>HTML5</code>中提供了<code>localStorage</code>来取代<code>globalStorage</code>。</p>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<p>###web storage和cookie的区别</p>
<p><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽，另外<code>cookie</code>还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<code>Web Storage</code>拥有<code>setItem,getItem,removeItem,clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie，getCookie</code>。</p>
<p>但是<code>cookie</code>也是不可以或缺的：<code>cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生</p>
<p>浏览器的支持除了<code>IE７</code>及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的<code>userData</code>其实就是<code>javascript</code>本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持<code>web storage</code>。</p>
<p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem、getItem</code>和<code>removeItem</code>等</p>
<p>###cookie 和session 的区别：</p>
<pre><code>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗

   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

    考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：

   将登陆信息等重要信息存放为SESSION

   其他信息如果需要保留，可以放在COOKIE中
</code></pre><p>##CSS 相关问题</p>
<blockquote>
<p><code>display:none</code>和<code>visibility:hidden</code>的区别？</p>
</blockquote>
<pre><code>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。

visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。
</code></pre><blockquote>
<p>CSS中<code>link</code> 和<code>@import</code>的区别是？</p>
</blockquote>
<pre><code>(1) link属于HTML标签，而@import是CSS提供的;

(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;

(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;

(4) link方式的样式的权重 高于@import的权重.
</code></pre><blockquote>
<p><code>position:absolute</code>和<code>float</code>属性的异同</p>
</blockquote>
<ul>
<li>共同点：对内联元素设置<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高。</li>
</ul>
<ul>
<li>不同点：<code>float</code>仍会占据位置，<code>position</code>会覆盖文档流中的其他元素。</li>
</ul>
<blockquote>
<p>介绍一下box-sizing属性？</p>
</blockquote>
<p><code>box-sizing</code>属性主要用来控制元素的盒模型的解析模式。默认值是<code>content-box</code>。</p>
<ul>
<li><p><code>content-box</code>：让元素维持W3C的标准盒模型。元素的宽度/高度由<code>border + padding + content</code>的宽度/高度决定，设置<code>width/height</code>属性指的是<code>content</code>部分的宽/高</p>
</li>
<li><p><code>border-box</code>：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置<code>width/height</code>属性指的是<code>border + padding + content</code></p>
</li>
</ul>
<p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p>
<blockquote>
<p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1<span class="selector-class">.id</span>选择器（ # <span class="selector-tag">myid</span>）</div><div class="line"></div><div class="line">2.类选择器（<span class="selector-class">.myclassname</span>）</div><div class="line"></div><div class="line">3.标签选择器（<span class="selector-tag">div</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">4.相邻选择器（<span class="selector-tag">h1</span> + <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">5.子选择器（<span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>）</div><div class="line"></div><div class="line">6.后代选择器（<span class="selector-tag">li</span> <span class="selector-tag">a</span>）</div><div class="line"></div><div class="line">7.通配符选择器（ * ）</div><div class="line"></div><div class="line">8.属性选择器（<span class="selector-tag">a</span><span class="selector-attr">[rel = "external"]</span>）</div><div class="line"></div><div class="line">9.伪类选择器（<span class="selector-tag">a</span>: <span class="selector-tag">hover</span>, <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>）</div></pre></td></tr></table></figure>
<p><strong>优先级为:</strong></p>
<p><code>!important &gt;  id &gt; class &gt; tag</code></p>
<p><code>important</code> 比 内联优先级高,但内联比 <code>id</code> 要高</p>
<blockquote>
<p>CSS3新增伪类举例：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-of-type</span> 选择属于其父元素的首个 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span>  选择属于其父元素的最后 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span>  选择属于其父元素唯一的 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span>    选择属于其父元素的唯一子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>  选择属于其父元素的第二个子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:enabled</span>  <span class="selector-pseudo">:disabled</span> 控制表单控件的禁用状态。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:checked</span>        单选框或复选框被选中。</div></pre></td></tr></table></figure>
<blockquote>
<p>CSS3有哪些新特性？</p>
</blockquote>
<pre><code>CSS3实现圆角（border-radius），阴影（box-shadow），

对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）

transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜

增加了更多的CSS选择器  多背景 rgba

在CSS3中唯一引入的伪元素是::selection.

媒体查询，多栏布局

border-image
</code></pre><p>CSS3中新增了一种盒模型计算方式：<code>box-sizing</code>。盒模型默认的值是<code>content-box</code>, 新增的值是<code>padding-box</code>和<code>border-box</code>，几种盒模型计算元素宽高的区别如下：</p>
<h4 id="content-box（默认）"><a href="#content-box（默认）" class="headerlink" title="content-box（默认）"></a><code>content-box（默认）</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Height = height + padding-top + padding-bottom + border-top + border-bottom</div><div class="line"></div><div class="line">padding-box</div></pre></td></tr></table></figure>
<p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div><div class="line"></div><div class="line">border-box</div></pre></td></tr></table></figure>
<p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure>
<blockquote>
<p>对BFC规范的理解？</p>
</blockquote>
<pre><code>  BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）
</code></pre><p>##html部分</p>
<p>###说说你对语义化的理解？</p>
<pre><code>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构

2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；

4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
</code></pre><p>###Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</p>
<p>1）、<code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</p>
<p>2）、严格模式的排版和 <code>JS</code> 运作模式是  以该浏览器支持的最高标准运行。</p>
<p>3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<p>4）、<code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现。</p>
<p>###你知道多少种<code>Doctype</code>文档类型？</p>
<pre><code> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。

 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。

 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。

Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks

 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。
</code></pre><p>###HTML与XHTML——二者有什么区别</p>
<pre><code>区别：

1.所有的标记都必须要有一个相应的结束标记

2.所有标签的元素和属性的名字都必须使用小写

3.所有的XML标记都必须合理嵌套

4.所有的属性必须用引号&quot;&quot;括起来

5.把所有&lt;和&amp;特殊符号用编码表示

6.给所有属性赋一个值

7.不要在注释内容中使“--”

8.图片必须有说明文字
</code></pre><p>###常见兼容性问题？</p>
<pre><code>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.

浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）

#box{ float:left; width:10px; margin:0 0 0 100px;}

这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入
_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

渐进识别的方式，从总体中逐渐排除局部。


  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。

  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

  css

      .bb{

       background-color:#f1ee18;/*所有识别*/

      .background-color:#00deff\9; /*IE6、7、8识别*/

      +background-color:#a200ff;/*IE6、7识别*/

      _background-color:#1e0bd1;/*IE6识别*/

      }


怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发
怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在
可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;`
</code></pre><blockquote>
<p>上下margin重合问题</p>
</blockquote>
<pre><code>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。

解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。
</code></pre><p>###解释下浮动和它的工作原理？清除浮动的技巧</p>
<pre><code>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。


1.使用空标签清除浮动。

   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。

2.使用overflow。

   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。

3.使用after伪对象清除浮动。

   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
</code></pre><p>###浮动元素引起的问题和解决办法？</p>
<pre><code>浮动元素引起的问题：

（1）父元素的高度无法被撑开，影响与父元素同级的元素

（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后

（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
</code></pre><blockquote>
<p>解决方法：</p>
</blockquote>
<p>使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>: <span class="string">"."</span>;<span class="attribute">display</span>: block;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">clear</span>: both;<span class="attribute">visibility</span>: hidden;&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.clearfix</span>&#123;<span class="attribute">display</span>: inline-block;&#125; <span class="comment">/* for IE/Mac */</span></div></pre></td></tr></table></figure>
<p><strong>清除浮动的几种方法：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1，额外标签法，&lt;div style="clear:both;"&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</div><div class="line"></div><div class="line">2，使用after伪类</div><div class="line"></div><div class="line">#parent:after&#123;</div><div class="line"></div><div class="line">    content:".";</div><div class="line"></div><div class="line">    height:0;</div><div class="line"></div><div class="line">    visibility:hidden;</div><div class="line"></div><div class="line">    display:block;</div><div class="line"></div><div class="line">    clear:both;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">3,浮动外部元素</div><div class="line"></div><div class="line">4,设置overflow为hidden或者auto</div></pre></td></tr></table></figure>
<p>###DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</p>
<blockquote>
<p>1）创建新节点</p>
</blockquote>
<pre><code>createDocumentFragment()    //创建一个DOM片段

createElement()   //创建一个具体的元素

createTextNode()   //创建一个文本节点
</code></pre><blockquote>
<p>2）添加、移除、替换、插入</p>
</blockquote>
<pre><code>appendChild()

removeChild()

replaceChild()

insertBefore() //并没有insertAfter()
</code></pre><blockquote>
<p>3）查找</p>
</blockquote>
<pre><code>getElementsByTagName()    //通过标签名称

getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，
会得到一个数组，其中包括id等于name值的)

getElementById()    //通过元素Id，唯一性
</code></pre><p>###html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p>
<pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

拖拽释放(Drag and drop) API

语义化更好的内容标签（header,nav,footer,aside,article,section）

音频、视频API(audio,video)

画布(Canvas) API

地理(Geolocation) API

本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

sessionStorage 的数据在浏览器关闭后自动删除


表单控件，calendar、date、time、email、url、search

新的技术webworker, websocket, Geolocation
</code></pre><p><img src="/imgs/what-is-html5.jpg" alt="what-is-html5"></p>
<blockquote>
<p>移除的元素</p>
</blockquote>
<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；
</code></pre><blockquote>
<p>支持HTML5新标签：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IE8/IE7/IE6支持通过document.createElement方法产生的标签，</div><div class="line"></div><div class="line">可以利用这一特性让这些浏览器支持HTML5新标签，</div><div class="line"></div><div class="line">当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</div><div class="line"></div><div class="line">   &lt;!--[if lt IE 9]&gt;</div><div class="line"></div><div class="line">   &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</div><div class="line"></div><div class="line">   &lt;![endif]--&gt;</div><div class="line"></div><div class="line">如何区分： DOCTYPE声明\新增的结构元素\功能元素</div></pre></td></tr></table></figure>
<p>###如何实现浏览器内多个标签页之间的通信?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">调用localstorge、cookies等本地存储方式</div></pre></td></tr></table></figure>
<p>###什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> FOUC - Flash Of Unstyled Content 文档样式闪烁</div><div class="line"></div><div class="line"> <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span>&gt;</span><span class="css">@<span class="keyword">import</span> <span class="string">"../fouc.css"</span>;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</div><div class="line"></div><div class="line"> 解决方法简单的出奇，只要在<span class="tag">&lt;<span class="name">head</span>&gt;</span>之间加入一个<span class="tag">&lt;<span class="name">link</span>&gt;</span>或者<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">元素就可以了。</span></div></pre></td></tr></table></figure>
<p>###null和undefined的区别？</p>
<p><code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>。</p>
<p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。</p>
<p><code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<pre><code>（1）变量被声明了，但没有赋值时，就等于undefined。


（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。


（3）对象没有赋值的属性，该属性的值为undefined。


（4）函数没有返回值时，默认返回undefined。
</code></pre><p><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</p>
<pre><code>（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。
</code></pre><p>###new操作符具体干了什么呢?</p>
<pre><code>   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

   2、属性和方法被加入到 this 引用的对象中。

   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。



var obj  = {};

obj.__proto__ = Base.prototype;

Base.call(obj);
</code></pre><p>###js延迟加载的方式有哪些？</p>
<pre><code>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js
</code></pre><p>###<code>call()</code> 和 <code>apply()</code> 的区别和作用？</p>
<p>作用：动态改变某个类的某个方法的运行环境（执行上下文）。</p>
<p>区别参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader15" target="_blank" rel="external">JavaScript学习总结（四）function函数部分</a></p>
<p>###哪些操作会造成内存泄漏？</p>
<pre><code>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。



setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</code></pre><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000687844" target="_blank" rel="external">详解js变量、作用域及内存</a></p>
<p>###列举IE 与其他浏览器不一样的特性？</p>
<ul>
<li><p>IE支持<code>currentStyle</code>，FIrefox使用<code>getComputStyle</code></p>
</li>
<li><p>IE  使用<code>innerText</code>，Firefox使用<code>textContent</code></p>
</li>
<li><p>滤镜方面：IE:<code>filter:alpha(opacity= num)</code>；Firefox：<code>-moz-opacity:num</code></p>
</li>
<li><p>事件方面：IE：<code>attachEvent</code>：火狐是<code>addEventListener</code></p>
</li>
<li><p>鼠标位置：IE是<code>event.clientX</code>；火狐是<code>event.pageX</code></p>
</li>
<li><p>IE使用<code>event.srcElement</code>；Firefox使用<code>event.target</code></p>
</li>
<li><p>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置<code>margin:0;padding:0以及list-style:none</code></p>
</li>
<li><p>CSS圆角：ie7以下不支持圆角</p>
</li>
</ul>
<p>###WEB应用从服务器主动推送Data到客户端有那些方式？</p>
<p>Javascript数据推送</p>
<ul>
<li><code>Commet</code>：基于HTTP长连接的服务器推送技术</li>
</ul>
<ul>
<li>基于<code>WebSocket</code>的推送方案</li>
</ul>
<ul>
<li><code>SSE</code>（Server-Send Event）：服务器推送数据新方式</li>
</ul>
<p>###对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p>
<pre><code>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。

    1、实现界面交互

    2、提升用户体验

    3、有了Node.js，前端可以实现服务端的一些事情


前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，



 参与项目，快速高质量完成实现效果图，精确到1px；

 与团队成员，UI设计，产品经理的沟通；

 做好的页面结构，页面重构和用户体验；

 处理hack，兼容、写出优美的代码格式；

 针对服务器的优化、拥抱最新前端技术。
</code></pre><p>###一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>
<pre><code>    分为4个步骤：

    （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。

    （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

    （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。

    （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。



请求返回后，便进入了我们关注的前端模块

简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM`
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000697254" target="_blank" rel="external">从输入 URL 到浏览器接收的过程中发生了什么事情？</a></p>
<p>###javascript对象的几种创建方式</p>
<pre><code>1，工厂模式

2，构造函数模式

3，原型模式

4，混合构造函数和原型模式

5，动态原型模式

6，寄生构造函数模式

7，稳妥构造函数模式
</code></pre><p>###javascript继承的6种方法</p>
<pre><code>1，原型链继承

2，借用构造函数继承

3，组合继承(原型+借用构造)

4，原型式继承

5，寄生式继承

6，寄生组合式继承
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<p>###ajax过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)创建<span class="string">`XMLHttpRequest`</span>对象,也就是创建一个异步调用对象.</div><div class="line"></div><div class="line">(<span class="number">2</span>)创建一个新的<span class="string">`HTTP`</span>请求,并指定该<span class="string">`HTTP`</span>请求的方法、<span class="string">`URL`</span>及验证信息.</div><div class="line"></div><div class="line">(<span class="number">3</span>)设置响应<span class="string">`HTTP`</span>请求状态变化的函数.</div><div class="line"></div><div class="line">(<span class="number">4</span>)发送<span class="string">`HTTP`</span>请求.</div><div class="line"></div><div class="line">(<span class="number">5</span>)获取异步调用返回的数据.</div><div class="line"></div><div class="line">(<span class="number">6</span>)使用JavaScript和DOM实现局部刷新.</div><div class="line"></div><div class="line"></div><div class="line">var xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">xmlHttp.open(<span class="string">'GET'</span>,<span class="string">'demo.php'</span>,<span class="string">'true'</span>);</div><div class="line"></div><div class="line">xmlHttp.send()</div><div class="line"></div><div class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<p>###异步加载和延迟加载</p>
<pre><code>1.异步加载的方案： 动态插入script标签

2.通过ajax去获取js代码，然后通过eval执行

3.script标签上添加defer或者async属性

4.创建并插入iframe，让它异步执行js

5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
</code></pre><p>###ie各版本和chrome可以并行下载多少个资源</p>
<pre><code>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个
Firefox，chrome也是6个
</code></pre><p>###<code>Flash</code>、<code>Ajax</code>各自的优缺点，在使用中如何取舍？</p>
<ul>
<li><code>Flash</code>适合处理多媒体、矢量图形、访问机器；对<code>CSS</code>、处理文本上不足，不容易被搜索。</li>
</ul>
<p>-<code>Ajax</code>对<code>CSS</code>、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<ul>
<li>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</li>
</ul>
<p>###请解释一下 JavaScript 的同源策略。</p>
<p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<p>###为什么要有同源限制？</p>
<p>   我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<p>缺点：</p>
<p>现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<p>###GET和POST的区别，何时使用POST？</p>
<pre><code>    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。


    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，

    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。



然而，在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）

向服务器发送大量数据（POST 没有数据量限制）

发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><p>###事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
<pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。

2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；

3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`;
</code></pre><p>###ajax的缺点和在IE下的问题？</p>
<p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<blockquote>
<p>ajax的缺点</p>
</blockquote>
<pre><code>1、ajax不支持浏览器back按钮。

2、安全问题 AJAX暴露了与服务器交互的细节。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试。
</code></pre><blockquote>
<p>IE缓存问题</p>
</blockquote>
<p>在IE浏览器下，如果请求的方法是<code>GET</code>，并且请求的<code>URL</code>不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的<code>URL</code>，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(<code>&#39;t&#39;= + new Date().getTime()</code>)</p>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open(&apos;GET&apos;,&apos;demo.php?rand=+Math.random()&apos;,true);//</div></pre></td></tr></table></figure>
<blockquote>
<p>Ajax请求的页面历史记录状态问题</p>
</blockquote>
<p>可以通过锚点来记录状态，<code>location.hash</code>。让浏览器记录Ajax请求时页面状态的变化。</p>
<p>还可以通过<code>HTML5</code>的<code>history.pushState</code>，来实现浏览器地址栏的无刷新改变</p>
<p>###js对象的深度克隆</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">Obj</span>) </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">var</span> buf;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line"></div><div class="line">          buf = [];  <span class="comment">//创建一个空的数组</span></div><div class="line"></div><div class="line">          <span class="keyword">var</span> i = Obj.length;</div><div class="line"></div><div class="line">          <span class="keyword">while</span> (i--) &#123;</div><div class="line"></div><div class="line">              buf[i] = clone(Obj[i]);</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> buf;</div><div class="line"></div><div class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line"></div><div class="line">          buf = &#123;&#125;;  <span class="comment">//创建一个空对象</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> Obj) &#123;  <span class="comment">//为这个对象添加新的属性</span></div><div class="line"></div><div class="line">              buf[k] = clone(Obj[k]);</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> buf;</div><div class="line"></div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> Obj;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>###网站重构的理解？</p>
<pre><code>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。


对于传统的网站来说重构通常是：

表格(table)布局改为DIV+CSS

使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)

对于移动平台的优化

针对于SEO进行优化

深层次的网站重构应该考虑的方面


减少代码间的耦合

让代码保持弹性

严格按规范编写代码

设计可扩展的API

代替旧有的框架、语言(如VB)

增强用户体验

通常来说对于速度的优化也包含在重构中



压缩JS、CSS、image等前端资源(通常是由服务器来解决)

程序的性能优化(如数据读写)

采用CDN来加速资源加载

对于JS DOM的优化

HTTP服务器的文件缓存
</code></pre><p>###js数组去重</p>
<p>以下是数组去重的三种方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> n = []; <span class="comment">//一个新的临时数组</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) <span class="comment">//遍历当前数组</span></div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前数组的第i已经保存进了临时数组，那么跳过，</span></div><div class="line"></div><div class="line">    <span class="comment">//否则把当前项push到临时数组里面</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>) n.push(<span class="keyword">this</span>[i]);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> n = &#123;&#125;,r=[]; <span class="comment">//n为hash表，r为临时数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) <span class="comment">//遍历当前数组</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!n[<span class="keyword">this</span>[i]]) <span class="comment">//如果hash表中没有当前项</span></div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            n[<span class="keyword">this</span>[i]] = <span class="literal">true</span>; <span class="comment">//存入hash表</span></div><div class="line"></div><div class="line">            r.push(<span class="keyword">this</span>[i]); <span class="comment">//把当前数组的当前项push到临时数组里面</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> r;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]]; <span class="comment">//结果数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) <span class="comment">//从第二项开始遍历</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="comment">//如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></div><div class="line"></div><div class="line">        <span class="comment">//那么表示第i项是重复的，忽略掉。否则存入结果数组</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) == i) n.push(<span class="keyword">this</span>[i]);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###HTTP状态码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</div><div class="line"></div><div class="line">200  OK   正常返回信息</div><div class="line"></div><div class="line">201  Created  请求成功并且服务器创建了新的资源</div><div class="line"></div><div class="line">202  Accepted  服务器已接受请求，但尚未处理</div><div class="line"></div><div class="line">301  Moved Permanently  请求的网页已永久移动到新位置。</div><div class="line"></div><div class="line">302 Found  临时性重定向。</div><div class="line"></div><div class="line">303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</div><div class="line"></div><div class="line">304  Not Modified  自从上次请求后，请求的网页未修改过。</div><div class="line"></div><div class="line"></div><div class="line">400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</div><div class="line"></div><div class="line">401 Unauthorized  请求未授权。</div><div class="line"></div><div class="line">403 Forbidden  禁止访问。</div><div class="line"></div><div class="line">404 Not Found  找不到如何与 URI 相匹配的资源。</div><div class="line"></div><div class="line">500 Internal Server Error  最常见的服务器端错误。</div><div class="line"></div><div class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</div></pre></td></tr></table></figure>
<p>###说说你对Promise的理解</p>
<p>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：</p>
<pre><code>pending: 初始状态, 非 fulfilled 或 rejected.

fulfilled: 成功的操作.

rejected: 失败的操作.

settled: Promise已被fulfilled或rejected，且不是pending
</code></pre><p>另外， <code>fulfilled</code> 与 <code>rejected</code> 一起合称 <code>settled</code>。</p>
<p><code>Promise</code> 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p>
<blockquote>
<p>Promise 的构造函数</p>
</blockquote>
<p>构造一个 <code>Promise</code>，最基本的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></div><div class="line"></div><div class="line">        resolve(result);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></div><div class="line"></div><div class="line">        reject(<span class="built_in">Error</span>(errMessage));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为 <code>thenable</code>）。它的使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在 <code>rejected</code> 的时候被调用，接收参数就是 <code>future，onFulfilled</code> 对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code>。</p>
<p>###说说你对前端架构师的理解</p>
<p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；<br>带领团队完成研发工具及平台前端部分的设计、研发和维护；<br>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先<br>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</p>
<p>###实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</div><div class="line"></div><div class="line">                o[e] = <span class="keyword">typeof</span> <span class="keyword">this</span>[e] === <span class="string">"object"</span> ? <span class="keyword">this</span>[e].clone() : <span class="keyword">this</span>[e];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> o;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###说说严格模式的限制</p>
<p>严格模式主要有以下限制：</p>
<pre><code>变量必须声明后再使用

函数的参数不能有同名属性，否则报错

不能使用with语句

不能对只读属性赋值，否则报错

不能使用前缀0表示八进制数，否则报错

不能删除不可删除的属性，否则报错

不能删除变量delete prop，会报错，只能删除属性delete global[prop]

eval不会在它的外层作用域引入变量

eval和arguments不能被重新赋值

arguments不会自动反映函数参数的变化

不能使用arguments.callee

不能使用arguments.caller

禁止this指向全局对象

不能使用fn.caller和fn.arguments获取函数调用的堆栈

增加了保留字（比如protected、static和interface）
</code></pre><p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li><p>消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
</li>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
</li>
<li><p>提高编译器效率，增加运行速度；</p>
</li>
<li><p>为未来新版本的<code>Javascript</code>做好铺垫。</p>
</li>
</ul>
<p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p>
<p>###什么是组件？</p>
<p>所谓组件，即封装起来的具有独立功能的UI部件。</p>
<blockquote>
<p>component , widget , module , plugin …etc</p>
</blockquote>
<p>###如何删除一个cookie</p>
<blockquote>
<p>1.将时间设为当前时间往前一点。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line">date.setDate(date.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></div></pre></td></tr></table></figure>
<p><code>setDate()</code>方法用于设置一个月的某一天。</p>
<blockquote>
<p>2.expires的设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>###<code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code>和<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>标签</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 标签和 <span class="tag">&lt;<span class="name">em</span>&gt;</span> 标签一样，用于强调文本，但它强调的程度更强一些。</div><div class="line"></div><div class="line">em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 <span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>;</div><div class="line"></div><div class="line"><span class="tag">&lt; <span class="attr">b</span> &gt;</span> <span class="tag">&lt; <span class="attr">i</span> &gt;</span>是视觉要素，分别表示无意义的加粗，无意义的斜体。</div><div class="line"></div><div class="line">em 和 strong 是表达要素(phrase elements)。</div></pre></td></tr></table></figure>
<p>###说说你对AMD和Commonjs的理解</p>
<p><br></p>
<p><code>CommonJS</code>是服务器端模块的规范，Node.js采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<p>###document.write()的用法</p>
<p><code>document.write()</code>方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。</p>
<p><code>document.write</code>只能重绘整个页面。<code>innerHTML</code>可以重绘页面的一部分</p>
<p>###编写一个方法 求一个字符串的字节长度</p>
<p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> len = str.length;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> bytes = len;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bytes;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</div></pre></td></tr></table></figure>
<h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a>git fetch和git pull的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git pull：相当于是从远程获取最新版本并merge到本地</div><div class="line"></div><div class="line">git fetch：相当于是从远程获取最新版本到本地，不会自动merge</div></pre></td></tr></table></figure>
<p>###如何居中一个浮动元素</p>
<p>父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对右移动50%，或者子元素相对左移动-50%也就可以了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;style type="text/css"&gt;</div><div class="line"></div><div class="line">    .p&#123;</div><div class="line"></div><div class="line">        position:relative;</div><div class="line"></div><div class="line">        left:50%;</div><div class="line"></div><div class="line">        float:left;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .c&#123;</div><div class="line"></div><div class="line">        position:relative;</div><div class="line"></div><div class="line">        float:left;</div><div class="line"></div><div class="line">        right:50%;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;div class="p"&gt;</div><div class="line"></div><div class="line">    &lt;h1 class="c"&gt;Test Float Element Center&lt;/h1&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>###css实现水平垂直居中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;style type="text/css"&gt;</div><div class="line"></div><div class="line">    .align-center&#123;</div><div class="line"></div><div class="line">        /*</div><div class="line"></div><div class="line">    负边距+定位：水平垂直居中（Negative Margin）</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    使用绝对定位将content的定点定位到body的中心，然后使用负margin（content宽高的一半），</div><div class="line"></div><div class="line">    将content的中心拉回到body的中心，已到达水平垂直居中的效果。</div><div class="line"></div><div class="line">        */</div><div class="line"></div><div class="line">        position:absolute;</div><div class="line"></div><div class="line">        left:50%;</div><div class="line"></div><div class="line">        top:50%;</div><div class="line"></div><div class="line">        width:400px;</div><div class="line"></div><div class="line">        height:400px;</div><div class="line"></div><div class="line">        margin-top:-200px;</div><div class="line"></div><div class="line">        margin-left:-200px;</div><div class="line"></div><div class="line">        border:1px dashed #333;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###css实现三栏布局，中间自适应</p>
<blockquote>
<p>方法一：自身浮动法。左栏左浮动，右栏右浮动。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.left , .right&#123;</div><div class="line"></div><div class="line">            height: 300px;</div><div class="line"></div><div class="line">            width: 200px;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .right&#123;</div><div class="line"></div><div class="line">            float: right;</div><div class="line"></div><div class="line">            background-color: red;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .left&#123;</div><div class="line"></div><div class="line">            float: left;</div><div class="line"></div><div class="line">            background-color: #080808;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .middle&#123;</div><div class="line"></div><div class="line">            height: 300px;</div><div class="line"></div><div class="line">            margin: 0 200px;//没有这行，当宽度缩小到一定程度的时候，中间的内容可能换行</div><div class="line"></div><div class="line">            background-color: blue;</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>方法二：margin负值法</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;style&gt;</div><div class="line"></div><div class="line">        body&#123;</div><div class="line"></div><div class="line">            margin: 0;</div><div class="line"></div><div class="line">            padding: 0;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .left , .right&#123;</div><div class="line"></div><div class="line">            height: 300px;</div><div class="line"></div><div class="line">            width: 200px;</div><div class="line"></div><div class="line">            float: left;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .right&#123;</div><div class="line"></div><div class="line">            margin-left: -200px;</div><div class="line"></div><div class="line">            background-color: red;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .left&#123;</div><div class="line"></div><div class="line">            margin-left: -100%;</div><div class="line"></div><div class="line">            background-color: #080808;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .middle&#123;</div><div class="line"></div><div class="line">            height: 300px;</div><div class="line"></div><div class="line">            width: 100%;</div><div class="line"></div><div class="line">            float: left;</div><div class="line"></div><div class="line">            background-color: blue;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/style&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&lt;!--放第一行--&gt;</div><div class="line"></div><div class="line">&lt;div class="middle"&gt;middle&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class="left"&gt;left&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class="right"&gt;right&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>方法三：绝对定位法。左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;style&gt;</div><div class="line">    body&#123;</div><div class="line"></div><div class="line">        margin: 0;</div><div class="line"></div><div class="line">        padding: 0;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .left , .right&#123;</div><div class="line"></div><div class="line">        top: 0;</div><div class="line"></div><div class="line">        height: 300px;</div><div class="line"></div><div class="line">        width: 200px;</div><div class="line"></div><div class="line">        position: absolute;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .right&#123;</div><div class="line"></div><div class="line">        right: 0;</div><div class="line"></div><div class="line">        background-color: red;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .left&#123;</div><div class="line"></div><div class="line">        left: 0;</div><div class="line"></div><div class="line">        background-color: #080808;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .middle&#123;</div><div class="line"></div><div class="line">        margin: 0 200px;</div><div class="line"></div><div class="line">        height: 300px;</div><div class="line"></div><div class="line">        background-color: blue;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;div class="left"&gt;left&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--这种方法没有严格限定中间这栏放置何处--&gt;</div><div class="line"></div><div class="line">&lt;div class="middle"&gt;middle&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class="right"&gt;right&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>###js常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等</p>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1</span>) 单例：　任意对象都是单例，无须特别处理</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">'michaelqin'</span>, age: <span class="number">30</span>&#125;;</div><div class="line"></div><div class="line"><span class="number">2</span>) 工厂: 就是同样形式参数返回不同的实例</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.name = <span class="string">'Person1'</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.name = <span class="string">'Animal1'</span>; &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Factory.prototype.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'new '</span> + className + <span class="string">'()'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> Factory();</div><div class="line"><span class="keyword">var</span> obj1 = factory.getInstance(<span class="string">'Person'</span>);</div><div class="line"><span class="keyword">var</span> obj2 = factory.getInstance(<span class="string">'Animal'</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// Person1</span></div><div class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// Animal1</span></div><div class="line"></div><div class="line"><span class="number">3</span>) 代理: 就是新建个类调用老类的接口,包一下</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'michaelqin'</span>); &#125;</div><div class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">30</span>); &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonProxy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.person = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.callMethod = <span class="function"><span class="keyword">function</span>(<span class="params">functionName</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'before proxy:'</span>, functionName);</div><div class="line">        that.person[functionName](); <span class="comment">// 代理</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'after proxy:'</span>, functionName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> pp = <span class="keyword">new</span> PersonProxy();</div><div class="line">pp.callMethod(<span class="string">'sayName'</span>); <span class="comment">// 代理调用Person的方法sayName()</span></div><div class="line">pp.callMethod(<span class="string">'sayAge'</span>); <span class="comment">// 代理调用Person的方法sayAge()</span></div><div class="line"></div><div class="line"><span class="number">4</span>) 观察者: 就是事件模式，比如按钮的onclick这样的应用.</div><div class="line">function Publisher() &#123;</div><div class="line">    <span class="keyword">this</span>.listeners = [];</div><div class="line">&#125;</div><div class="line">Publisher.prototype = &#123;</div><div class="line">    <span class="string">'addListener'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">listener</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.listeners.push(listener);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="string">'removeListener'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">listener</span>) </span>&#123;</div><div class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.listeners[listener];</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="string">'notify'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.listeners.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> listener = <span class="keyword">this</span>.listeners[i];</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'undefined'</span>) &#123;</div><div class="line">                listener.process(obj);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;; <span class="comment">// 发布者</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subscriber</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Subscriber.prototype = &#123;</div><div class="line">    <span class="string">'process'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj);</div><div class="line">    &#125;</div><div class="line">&#125;;　<span class="comment">// 订阅者</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> publisher = <span class="keyword">new</span> Publisher();</div><div class="line">publisher.addListener(<span class="keyword">new</span> Subscriber());</div><div class="line">publisher.addListener(<span class="keyword">new</span> Subscriber());</div><div class="line">publisher.notify(&#123;name: <span class="string">'michaelqin'</span>, ageo: <span class="number">30</span>&#125;); <span class="comment">// 发布一个对象到所有订阅者</span></div><div class="line">publisher.notify(<span class="string">'2 subscribers will both perform process'</span>); <span class="comment">// 发布一个字符串到所有订阅者</span></div></pre></td></tr></table></figure>
<p>###说说你对MVC和MVVM的理解</p>
<blockquote>
<p><code>MVC</code></p>
</blockquote>
<pre><code>View 传送指令到 Controller

Controller 完成业务逻辑后，要求 Model 改变状态

Model 将新的数据发送到 View，用户得到反馈
</code></pre><p>所有通信都是单向的。</p>
<p><code>Angular</code>它采用双向绑定（data-binding）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然。</p>
<pre><code>组成部分Model、View、ViewModel


View：UI界面


ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；


Model：数据访问层
</code></pre><p>###请解释什么是事件代理</p>
<p>事件代理（Event Delegation），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是<code>DOM</code>元素的事件冒泡。使用事件代理的好处是可以提高性能。</p>
<p>###attribute和property的区别是什么？</p>
<p><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</p>
<p><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</p>
<p>所以：</p>
<p>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的，</p>
<p>但是对于自定义的属性来说，他们是不同步的，</p>
<p>###说说网络分层里七层模型是哪七层</p>
<p>应用层：应用层、表示层、会话层（从上往下）（<code>HTTP、FTP、SMTP、DNS</code>）</p>
<p>传输层（<code>TCP</code>和<code>UDP</code>）</p>
<p>网络层（<code>IP</code>）</p>
<p>物理和数据链路层（以太网）</p>
<blockquote>
<p>每一层的作用如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</div><div class="line">数据链路层：将比特组装成帧和点到点的传递（帧Frame）</div><div class="line">网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</div><div class="line">传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</div><div class="line">会话层：建立、管理和终止会话（会话协议数据单元SPDU）</div><div class="line">表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</div><div class="line">应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</div></pre></td></tr></table></figure>
<blockquote>
<p>各种协议</p>
</blockquote>
<p><code>ICMP协议</code>： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br><code>TFTP协议</code>： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br><code>HTTP协议</code>： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br><code>DHCP协议</code>： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<p>###说说mongoDB和MySQL的区别</p>
<p><code>MySQL</code>是传统的关系型数据库，<code>MongoDB</code>则是非关系型数据库</p>
<p> <code>mongodb</code>以<code>BSON</code>结构（二进制）进行存储，对海量数据存储有着很明显的优势。</p>
<p>###讲讲304缓存的原理</p>
<p>服务器首先产生<code>ETag</code>，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p><br></p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>
<p><br></p>
<p>客户端请求一个页面（A）。 服务器返回页面A，并在给<code>A</code>加上一个<code>ETag</code>。 客户端展现该页面，并将页面连同<code>ETag</code>一起缓存。 客户再次请求页面<code>A</code>，并将上次请求时服务器返回的<code>ETag</code>一起传递给服务器。 服务器检查该<code>ETag</code>，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应<code>304</code>（未修改——<code>Not Modified</code>）和一个空的响应体。</p>
<p><br></p>
<p>###什么样的前端代码是好的</p>
<p>高复用低耦合，这样文件小，好维护，而且好扩展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/Front-end-Interview-questions/" data-id="cirx73hw3000ye2ufa6kotebe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cookieandsession" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/cookieandsession/" class="article-date">
  <time datetime="2016-05-03T05:22:39.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/cookieandsession/">cookie 和 session</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h1><p>众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？</p>
<p>比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：</p>
<ul>
<li>服务器向客户端发送 cookie。<ul>
<li>通常使用 HTTP 协议规定的 set-cookie 头操作。</li>
<li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。</li>
</ul>
</li>
<li>浏览器将 cookie 保存。</li>
<li>每次请求浏览器都会将 cookie 发向服务器。</li>
</ul>
<p>其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：</p>
<ul>
<li>path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。</li>
<li>expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。</li>
<li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li>
<li>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</li>
</ul>
<h3 id="express-中的-cookie"><a href="#express-中的-cookie" class="headerlink" title="express 中的 cookie"></a>express 中的 cookie</h3><p>express 在 4.x 版本之后，session管理和cookies等许多模块都不再直接包含在express中，而是需要单独添加相应模块。</p>
<p>express4 中操作 cookie 使用 <code>cookie-parser</code> 模块(<a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="external">https://github.com/expressjs/cookie-parser</a> )。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="comment">// 首先引入 cookie-parser 这个模块</span></div><div class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.listen(<span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用 cookieParser 中间件，cookieParser(secret, options)</span></div><div class="line"><span class="comment">// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）</span></div><div class="line"><span class="comment">// options 传入上面介绍的 cookie 可选参数</span></div><div class="line">app.use(cookieParser());</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果请求中的 cookie 存在 isVisit, 则输出 cookie</span></div><div class="line">  <span class="comment">// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟</span></div><div class="line">  <span class="keyword">if</span> (req.cookies.isVisit) &#123;</div><div class="line">    <span class="built_in">console</span>.log(req.cookies);</div><div class="line">    res.send(<span class="string">"再次欢迎访问"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.cookie(<span class="string">'isVisit'</span>, <span class="number">1</span>, &#123;maxAge: <span class="number">60</span> * <span class="number">1000</span>&#125;);</div><div class="line">    res.send(<span class="string">"欢迎第一次访问"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。</p>
<p>session 的运作通过一个 <code>session_id</code> 来进行。<code>session_id</code> 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 <code>connect.sid</code> 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。</p>
<p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 <code>connect.sid</code> 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p>
<p>session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中。线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到。</p>
<p>express 中操作 session 要用到 <code>express-session</code> (<a href="https://github.com/expressjs/session" target="_blank" rel="external">https://github.com/expressjs/session</a> ) 这个模块，主要的方法就是 <code>session(options)</code>，其中 options 中包含可选参数，主要有：</p>
<ul>
<li>name: 设置 cookie 中，保存 session 的字段名称，默认为 <code>connect.sid</code> 。</li>
<li>store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。</li>
<li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。</li>
<li>cookie: 设置存放 session id 的 cookie 的相关选项，默认为<ul>
<li>(default: { path: ‘/‘, httpOnly: true, secure: false, maxAge: null })</li>
</ul>
</li>
<li>genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 <code>uid2</code> 这个 npm 包。</li>
<li>rolling: 每个请求都重新设置一个 cookie，默认为 false。</li>
<li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true。</li>
</ul>
<p>1） 在内存中存储 session</p>
<p><code>express-session</code> 默认使用内存来存 session，对于开发调试来说很方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="comment">// 首先引入 express-session 这个模块</span></div><div class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.listen(<span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 按照上面的解释，设置 session 的可选参数</span></div><div class="line">app.use(session(&#123;</div><div class="line">  secret: <span class="string">'recommand 128 bytes random string'</span>, <span class="comment">// 建议使用 128 个字符的随机字符串</span></div><div class="line">  cookie: &#123; maxAge: <span class="number">60</span> * <span class="number">1000</span> &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 检查 session 中的 isVisit 字段</span></div><div class="line">  <span class="comment">// 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。</span></div><div class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</div><div class="line">    req.session.isVisit++;</div><div class="line">    res.send(<span class="string">'&lt;p&gt;第 '</span> + req.session.isVisit + <span class="string">'次来此页面&lt;/p&gt;'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    req.session.isVisit = <span class="number">1</span>;</div><div class="line">    res.send(<span class="string">"欢迎第一次来这里"</span>);</div><div class="line">    <span class="built_in">console</span>.log(req.session);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>2） 在 redis 中存储 session</p>
<p>session 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session。</p>
<p>假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中。而下一次访问时，他被负载均衡到了进程2，则此时进程2的内存中没有他的信息，认为他是个新用户。这就会导致用户在我们服务中的状态不一致。</p>
<p>使用 redis 作为缓存，可以使用 <code>connect-redis</code> 模块(<a href="https://github.com/tj/connect-redis" target="_blank" rel="external">https://github.com/tj/connect-redis</a> )来得到 redis 连接实例，然后在 session 中设置存储方式为该实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</div><div class="line"><span class="keyword">var</span> redisStore = <span class="built_in">require</span>(<span class="string">'connect-redis'</span>)(session);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.listen(<span class="number">5000</span>);</div><div class="line"></div><div class="line">app.use(session(&#123;</div><div class="line">  <span class="comment">// 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行。</span></div><div class="line">  <span class="comment">// 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用，比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法。</span></div><div class="line">  <span class="comment">// 编写自己的 store 也很简单</span></div><div class="line">  store: <span class="keyword">new</span> redisStore(),</div><div class="line">  secret: <span class="string">'somesecrettoken'</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</div><div class="line">    req.session.isVisit++;</div><div class="line">    res.send(<span class="string">'&lt;p&gt;第 '</span> + req.session.isVisit + <span class="string">'次来到此页面&lt;/p&gt;'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    req.session.isVisit = <span class="number">1</span>;</div><div class="line">    res.send(<span class="string">'欢迎第一次来这里'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们可以运行 <code>redis-cli</code> 查看结果，如图可以看到 redis 中缓存结果。</p>
<p><img src="https://github.com/Ricardo-Li/node-lessons/blob/master/lesson16/1.png" alt=""></p>
<h3 id="各种存储的利弊"><a href="#各种存储的利弊" class="headerlink" title="各种存储的利弊"></a>各种存储的利弊</h3><p>上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库</p>
<p>其中，开发环境存内存就好了。一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题。但内存 session 除了省事之外，没有别的好处。</p>
<p>cookie session 我们下面会提到，现在说说利弊。用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息。当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的。它的弊端是增大了数据量传输，利端是方便。</p>
<p>缓存方式是最常用的方式了，即快，又能共享状态。相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输。推荐使用。</p>
<p>数据库 session。除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧。</p>
<h3 id="signedCookie"><a href="#signedCookie" class="headerlink" title="signedCookie"></a>signedCookie</h3><p>上面都是讲基础，现在讲一些专业点的。</p>
<p>上面有提到</p>
<blockquote>
<p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造</p>
</blockquote>
<p>其实不是这样的，那只是为了方便理解才那么写。要知道，计算机领域有个名词叫 <strong>签名</strong>，专业点说，叫 <strong>信息摘要算法</strong>。</p>
<p>比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证。相应的 cookie 长这样：<code>dotcom_user=alsotang</code>，它说明现在的用户是 alsotang 这个用户。如果我在浏览器中装个插件，把它改成 <code>dotcom_user=ricardo</code>，服务器一读取，就会误认为我是 ricardo。然后我就可以进行 ricardo 才能进行的操作了。之前 web 开发不成熟的时候，用这招甚至可以黑个网站下来，把 cookie 改成 <code>dotcom_user=admin</code> 就行了，唉，那是个玩黑客的黄金年代啊。</p>
<p>OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名。</p>
<p>假设我的服务器有个秘密字符串，是 <code>this_is_my_secret_and_fuck_you_all</code>，我为用户 cookie 的 <code>dotcom_user</code> 字段设置了个值 <code>alsotang</code>。cookie 本应是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;dotcom_user: <span class="string">'alsotang'</span>&#125;</div></pre></td></tr></table></figure>
<p>这样的。</p>
<p>而如果我们签个名，比如把 <code>dotcom_user</code> 的值跟我的 secret_string 做个 sha1</p>
<p><code>sha1(&#39;this_is_my_secret_and_fuck_you_all&#39; + &#39;alsotang&#39;) === &#39;4850a42e3bc0d39c978770392cbd8dc2923e3d1d&#39;</code></p>
<p>然后把 cookie 变成这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  dotcom_user: <span class="string">'alsotang'</span>,</div><div class="line">  <span class="string">'dotcom_user.sig'</span>: <span class="string">'4850a42e3bc0d39c978770392cbd8dc2923e3d1d'</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，用户就没法伪造信息了。一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致。</p>
<p>毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高。</p>
<h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie-session"></a>cookie-session</h3><p><del><br>上面一直提到 session 可以存在 cookie 中，现在来讲讲具体的思路。这里所涉及的专业名词叫做 对称加密。</del></p>
<p>假设我们想在用户的 cookie 中存 session data，使用一个名为 <code>session_data</code> 的字段。</p>
<p>存</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sessionData = &#123;username: <span class="string">'alsotang'</span>, age: <span class="number">22</span>, company: <span class="string">'alibaba'</span>, location: <span class="string">'hangzhou'</span>&#125;</div></pre></td></tr></table></figure>
<p>这段信息的话，可以将 <code>sessionData</code> 与我们的 <code>secret_string</code> 一起做个对称加密，存到 cookie 的 <code>session_data</code> 字段中，只要你的 <code>secret_string</code> 足够长，那么攻击者也是无法获取实际 session 内容的。对称加密之后的内容对于攻击者来说相当于一段乱码。</p>
<p>而当用户下次访问时，我们就可以用 <code>secret_string</code> 来解密 <code>sessionData</code>，得到我们需要的 session data。</p>
<p>signedCookies 跟 cookie-session 还是有区别的：</p>
<p>1）是前者信息可见不可篡改，后者不可见也不可篡改</p>
<p>2）是前者一般是长期保存，而后者是 session cookie<br></p>
<p>cookie-session 的实现跟 signedCookies 差不多。</p>
<p>不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险。</p>
<p>回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中。他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了。而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分。</p>
<p>如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中。这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了。如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中。</p>
<h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session cookie"></a>session cookie</h3><p>初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。</p>
<p>常见的场景就是在开发用户登陆状态保持时。</p>
<p>假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。</p>
<p>比如有这样一个用户</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;username: <span class="string">'alsotang'</span>, age: <span class="number">22</span>, company: <span class="string">'alibaba'</span>, location: <span class="string">'hangzhou'</span>&#125;</div></pre></td></tr></table></figure>
<p>我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username。</p>
<p>登陆的检验过程伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (req.session.user) &#123;</div><div class="line">  <span class="comment">// 获取 user 并进行下一步</span></div><div class="line">  next()</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.signedCookies[<span class="string">'username'</span>]) &#123;</div><div class="line">  <span class="comment">// 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中</span></div><div class="line">  getuser(<span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</div><div class="line">    req.session.user = user;</div><div class="line">    next();</div><div class="line">  &#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 当做为登陆用户处理</span></div><div class="line">  next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="etag-当做-session，保存-http-会话"><a href="#etag-当做-session，保存-http-会话" class="headerlink" title="etag 当做 session，保存 http 会话"></a>etag 当做 session，保存 http 会话</h3><p>很黑客的一种玩法：<a href="https://cnodejs.org/topic/5212d82d0a746c580b43d948" target="_blank" rel="external">https://cnodejs.org/topic/5212d82d0a746c580b43d948</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/cookieandsession/" data-id="cirx73hu20005e2ufk229h9jc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-setExpress" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/setExpress/" class="article-date">
  <time datetime="2016-05-03T05:22:39.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/setExpress/">搭建一个express应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>express 是基于 node.js 的 web 应用开发框架，可以快速搭建一个网站。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-安装node"><a href="#1-安装node" class="headerlink" title="1.安装node"></a>1.安装node</h3><p>这个不用多说</p>
<h3 id="2-安装express"><a href="#2-安装express" class="headerlink" title="2.安装express"></a>2.安装express</h3><p>直接使用 npm install -g express 会报错。这里需要使用 sudo 命令获得 root 权限，然后输入密码安装 express 。命令为：sudo npm install -g express 。这时express已经安装完了，输入 express -V （注意这里V大写），会提示 express 命令无法识别。这是因为 express4 版本将命令行工具 express 单独分离出来了，放到 express-generator 包中，老版本是集成在一起的。所以我们还需要执行 sudo install -g express-generator，现在就可以使用 express -V 命令查看 express 的版本号了。</p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>直接在命令行中输入 express -e MyProjectName 就可以创建一个使用ejs模板的应用了。创建完成后项目目录结构如下图。<br>（不管你信不信，这是一张图）<br>进入bin目录，里面有一个 www 文件，我们的应用就是通过它来启动的。在命令行中输入node www,按回车。通过浏览器访问 127.0.0.1:3000 就可以看到 Welcome to Express 了，这样我们就成功地使用 express 创建了一个简单的应用。</p>
<h2 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h2><p>使用 node www 启动应用后，如果我们对文件有修改，需要 crl+c 关闭应用，然后再重新启动才能在浏览器中看到修改。<br>forever可以看做是一个 node 的守护进程，使用 forever 能够启动、停止、重启 node 应用。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>sudo npm install -g forever  //全局安装forever
</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>forever start bin/www  //启动我们上面创建的应用
forever start -w bin/www //启动并监听项目下的所有文件，修改后会重启应用
</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>forever stop bin/www //停止应用
forever stopall //停止所以应用
</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>forever restart bin/www  //重启应用
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/setExpress/" data-id="cirx73hvl000se2uf1sduqrl8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-usemongo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/usemongo/" class="article-date">
  <time datetime="2016-05-03T05:22:39.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/usemongo/">在mac中安装和配置MongoDB</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可以通过 <a href="https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.4.tgz" target="_blank" rel="external">官网</a> 下载 MongoDB 。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.下载完成后解压到任意目录。<br>2.打开终端进入MongoDB目录，新建mongodb数据库文件夹<br>3.给数据库文件夹赋予读写权限： sudo chown -R data<br>4.设置数据库文件路径权限并启动 bin/mongod –dbpath 路径（需要注意一点，默认是dbpath=/data/db，所以如果数据库文件夹不是这个的话，每次都要把路径加上）</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>输入 bin/mongod ，按回车，然后看到下面这样的提示，就说明我们已经成功启动数据库了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-04-13T15:53:07.551+0800 I CONTROL  [initandlisten] MongoDB starting : pid=57287 port=27017 dbpath=/data/db 64-bit host=molindeMacBook-Pro.local</div></pre></td></tr></table></figure></p>
<p>在浏览器中打开 27017 端口就可以看到了。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>终端中输入 bin/mongo 按回车，就可以对数据库进行操作了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">db.createUser(&#123;user: &quot;accountUser&quot;,pwd: &quot;password&quot;,roles: [ &quot;readWrite&quot;, &quot;dbAdmin&quot; ]&#125;) //创建用户</div><div class="line">db.dropUser(&apos;accountUser&apos;); //删除用户</div><div class="line">show users //查看所有用户</div><div class="line">show dbs  //查看数据库</div><div class="line">show collections //查看集合</div><div class="line">db.createColletion(&apos;newCollection&apos;) //创建集合</div><div class="line">coll=db.getCollection(&apos;newCollection&apos;) //进如集合</div><div class="line">coll.find(); //查看集合中所有数据</div><div class="line">coll.find(&#123;name:&apos;molin&apos;&#125;); //查看name=‘molin’的数据</div><div class="line">coll.insert(&#123;name:&apos;Admin&apos;,age:&apos;23&apos;&#125;) //添加数据</div><div class="line">coll.remove(&#123;age:&apos;23&apos;&#125;); //删除数据</div><div class="line">coll.update(&#123;name:&apos;Admin&apos;&#125;,&#123;$set:&#123;age:&apos;age2&apos;&#125;&#125;,&#123;upsert:false,multi:true&#125;); //把name=‘Admin’ 的age改为age2，两个参数：upsert是true时，如果没有找到就会新增一条数据，multi如果为true就会更改多条匹配的数据（否则只改第一条）。</div><div class="line">coll.save(&#123;name:&apos;Admin&apos;,name:&apos;4&apos;,age:&apos;4&apos;&#125;); //把name=‘Admin’的name改为4，age改为4</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/usemongo/" data-id="cirx73hvm000te2ufbbai7udn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/15/saesign/">怎么去掉sae的实名认证提示</a>
          </li>
        
          <li>
            <a href="/2016/08/12/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/08/12/hexo/">如何在githuhb上面搭建一个博客</a>
          </li>
        
          <li>
            <a href="/2016/08/11/emoji/">怎么能够阻止在输入框中输入emoji表情</a>
          </li>
        
          <li>
            <a href="/2016/08/10/zeptozip/">使用require和zepto在打包时存在的问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>